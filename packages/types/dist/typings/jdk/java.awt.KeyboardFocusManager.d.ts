declare namespace java {
    namespace awt {
        // @ts-ignore
        abstract class KeyboardFocusManager extends java.lang.Object {
            /**
             * Initializes a KeyboardFocusManager.
             */
            // @ts-ignore
            constructor()
            // @ts-ignore
            public static FORWARD_TRAVERSAL_KEYS: number;
            // @ts-ignore
            public static BACKWARD_TRAVERSAL_KEYS: number;
            // @ts-ignore
            public static UP_CYCLE_TRAVERSAL_KEYS: number;
            // @ts-ignore
            public static DOWN_CYCLE_TRAVERSAL_KEYS: number;
            /**
             * Returns the current KeyboardFocusManager instance for the calling
             * thread's context.
             */
            // @ts-ignore
            public static getCurrentKeyboardFocusManager(): java.awt.KeyboardFocusManager;
            /**
             * Sets the current KeyboardFocusManager instance for the calling thread's
             * context. If null is specified, then the current KeyboardFocusManager
             * is replaced with a new instance of DefaultKeyboardFocusManager.
             * <p>
             * If a SecurityManager is installed, the calling thread must be granted
             * the AWTPermission "replaceKeyboardFocusManager" in order to replace the
             * the current KeyboardFocusManager. If this permission is not granted,
             * this method will throw a SecurityException, and the current
             * KeyboardFocusManager will be unchanged.
             */
            // @ts-ignore
            public static setCurrentKeyboardFocusManager(newManager: java.awt.KeyboardFocusManager): void;
            /**
             * Returns the focus owner, if the focus owner is in the same context as
             * the calling thread. The focus owner is defined as the Component in an
             * application that will typically receive all KeyEvents generated by the
             * user. KeyEvents which map to the focus owner's focus traversal keys will
             * not be delivered if focus traversal keys are enabled for the focus
             * owner. In addition, KeyEventDispatchers may retarget or consume
             * KeyEvents before they reach the focus owner.
             */
            // @ts-ignore
            public getFocusOwner(): java.awt.Component;
            /**
             * Returns the focus owner, even if the calling thread is in a different
             * context than the focus owner. The focus owner is defined as the
             * Component in an application that will typically receive all KeyEvents
             * generated by the user. KeyEvents which map to the focus owner's focus
             * traversal keys will not be delivered if focus traversal keys are enabled
             * for the focus owner. In addition, KeyEventDispatchers may retarget or
             * consume KeyEvents before they reach the focus owner.
             * <p>
             * This method will throw a SecurityException if this KeyboardFocusManager
             * is not the current KeyboardFocusManager for the calling thread's
             * context.
             */
            // @ts-ignore
            protected getGlobalFocusOwner(): java.awt.Component;
            /**
             * Sets the focus owner. The operation will be cancelled if the Component
             * is not focusable. The focus owner is defined as the Component in an
             * application that will typically receive all KeyEvents generated by the
             * user. KeyEvents which map to the focus owner's focus traversal keys will
             * not be delivered if focus traversal keys are enabled for the focus
             * owner. In addition, KeyEventDispatchers may retarget or consume
             * KeyEvents before they reach the focus owner.
             * <p>
             * This method does not actually set the focus to the specified Component.
             * It merely stores the value to be subsequently returned by
             * <code>getFocusOwner()</code>. Use <code>Component.requestFocus()</code>
             * or <code>Component.requestFocusInWindow()</code> to change the focus
             * owner, subject to platform limitations.
             */
            // @ts-ignore
            protected setGlobalFocusOwner(focusOwner: java.awt.Component): void;
            /**
             * Clears the focus owner at both the Java and native levels if the
             * focus owner exists and resides in the same context as the calling thread,
             * otherwise the method returns silently.
             * <p>
             * The focus owner component will receive a permanent FOCUS_LOST event.
             * After this operation completes, the native windowing system will discard
             * all user-generated KeyEvents until the user selects a new Component to
             * receive focus, or a Component is given focus explicitly via a call to
             * {@code requestFocus()}. This operation does not change the focused or
             * active Windows.
             */
            // @ts-ignore
            public clearFocusOwner(): void;
            /**
             * Clears the global focus owner at both the Java and native levels. If
             * there exists a focus owner, that Component will receive a permanent
             * FOCUS_LOST event. After this operation completes, the native windowing
             * system will discard all user-generated KeyEvents until the user selects
             * a new Component to receive focus, or a Component is given focus
             * explicitly via a call to <code>requestFocus()</code>. This operation
             * does not change the focused or active Windows.
             * <p>
             * If a SecurityManager is installed, the calling thread must be granted
             * the "replaceKeyboardFocusManager" AWTPermission. If this permission is
             * not granted, this method will throw a SecurityException, and the current
             * focus owner will not be cleared.
             * <p>
             * This method is intended to be used only by KeyboardFocusManager set as
             * current KeyboardFocusManager for the calling thread's context. It is not
             * for general client use.
             */
            // @ts-ignore
            public clearGlobalFocusOwner(): void;
            /**
             * Returns the permanent focus owner, if the permanent focus owner is in
             * the same context as the calling thread. The permanent focus owner is
             * defined as the last Component in an application to receive a permanent
             * FOCUS_GAINED event. The focus owner and permanent focus owner are
             * equivalent unless a temporary focus change is currently in effect. In
             * such a situation, the permanent focus owner will again be the focus
             * owner when the temporary focus change ends.
             */
            // @ts-ignore
            public getPermanentFocusOwner(): java.awt.Component;
            /**
             * Returns the permanent focus owner, even if the calling thread is in a
             * different context than the permanent focus owner. The permanent focus
             * owner is defined as the last Component in an application to receive a
             * permanent FOCUS_GAINED event. The focus owner and permanent focus owner
             * are equivalent unless a temporary focus change is currently in effect.
             * In such a situation, the permanent focus owner will again be the focus
             * owner when the temporary focus change ends.
             */
            // @ts-ignore
            protected getGlobalPermanentFocusOwner(): java.awt.Component;
            /**
             * Sets the permanent focus owner. The operation will be cancelled if the
             * Component is not focusable. The permanent focus owner is defined as the
             * last Component in an application to receive a permanent FOCUS_GAINED
             * event. The focus owner and permanent focus owner are equivalent unless
             * a temporary focus change is currently in effect. In such a situation,
             * the permanent focus owner will again be the focus owner when the
             * temporary focus change ends.
             * <p>
             * This method does not actually set the focus to the specified Component.
             * It merely stores the value to be subsequently returned by
             * <code>getPermanentFocusOwner()</code>. Use
             * <code>Component.requestFocus()</code> or
             * <code>Component.requestFocusInWindow()</code> to change the focus owner,
             * subject to platform limitations.
             */
            // @ts-ignore
            protected setGlobalPermanentFocusOwner(permanentFocusOwner: java.awt.Component): void;
            /**
             * Returns the focused Window, if the focused Window is in the same context
             * as the calling thread. The focused Window is the Window that is or
             * contains the focus owner.
             */
            // @ts-ignore
            public getFocusedWindow(): java.awt.Window;
            /**
             * Returns the focused Window, even if the calling thread is in a different
             * context than the focused Window. The focused Window is the Window that
             * is or contains the focus owner.
             */
            // @ts-ignore
            protected getGlobalFocusedWindow(): java.awt.Window;
            /**
             * Sets the focused Window. The focused Window is the Window that is or
             * contains the focus owner. The operation will be cancelled if the
             * specified Window to focus is not a focusable Window.
             * <p>
             * This method does not actually change the focused Window as far as the
             * native windowing system is concerned. It merely stores the value to be
             * subsequently returned by <code>getFocusedWindow()</code>. Use
             * <code>Component.requestFocus()</code> or
             * <code>Component.requestFocusInWindow()</code> to change the focused
             * Window, subject to platform limitations.
             */
            // @ts-ignore
            protected setGlobalFocusedWindow(focusedWindow: java.awt.Window): void;
            /**
             * Returns the active Window, if the active Window is in the same context
             * as the calling thread. Only a Frame or a Dialog can be the active
             * Window. The native windowing system may denote the active Window or its
             * children with special decorations, such as a highlighted title bar.
             * The active Window is always either the focused Window, or the first
             * Frame or Dialog that is an owner of the focused Window.
             */
            // @ts-ignore
            public getActiveWindow(): java.awt.Window;
            /**
             * Returns the active Window, even if the calling thread is in a different
             * context than the active Window. Only a Frame or a Dialog can be the
             * active Window. The native windowing system may denote the active Window
             * or its children with special decorations, such as a highlighted title
             * bar. The active Window is always either the focused Window, or the first
             * Frame or Dialog that is an owner of the focused Window.
             */
            // @ts-ignore
            protected getGlobalActiveWindow(): java.awt.Window;
            /**
             * Sets the active Window. Only a Frame or a Dialog can be the active
             * Window. The native windowing system may denote the active Window or its
             * children with special decorations, such as a highlighted title bar. The
             * active Window is always either the focused Window, or the first Frame or
             * Dialog that is an owner of the focused Window.
             * <p>
             * This method does not actually change the active Window as far as the
             * native windowing system is concerned. It merely stores the value to be
             * subsequently returned by <code>getActiveWindow()</code>. Use
             * <code>Component.requestFocus()</code> or
             * <code>Component.requestFocusInWindow()</code>to change the active
             * Window, subject to platform limitations.
             */
            // @ts-ignore
            protected setGlobalActiveWindow(activeWindow: java.awt.Window): void;
            /**
             * Returns the default FocusTraversalPolicy. Top-level components
             * use this value on their creation to initialize their own focus traversal
             * policy by explicit call to Container.setFocusTraversalPolicy.
             */
            // @ts-ignore
            public getDefaultFocusTraversalPolicy(): java.awt.FocusTraversalPolicy;
            /**
             * Sets the default FocusTraversalPolicy. Top-level components
             * use this value on their creation to initialize their own focus traversal
             * policy by explicit call to Container.setFocusTraversalPolicy.
             * Note: this call doesn't affect already created components as they have
             * their policy initialized. Only new components will use this policy as
             * their default policy.
             */
            // @ts-ignore
            public setDefaultFocusTraversalPolicy(defaultPolicy: java.awt.FocusTraversalPolicy): void;
            /**
             * Sets the default focus traversal keys for a given traversal operation.
             * This traversal key {@code Set} will be in effect on all
             * {@code Window}s that have no such {@code Set} of
             * their own explicitly defined. This {@code Set} will also be
             * inherited, recursively, by any child {@code Component} of
             * those {@code Windows} that has
             * no such {@code Set} of its own explicitly defined.
             * <p>
             * The default values for the default focus traversal keys are
             * implementation-dependent. Sun recommends that all implementations for a
             * particular native platform use the same default values. The
             * recommendations for Windows and Unix are listed below. These
             * recommendations are used in the Sun AWT implementations.
             * <table border=1 summary="Recommended default values for focus traversal keys">
             * <tr>
             * <th>Identifier</th>
             * <th>Meaning</th>
             * <th>Default</th>
             * </tr>
             * <tr>
             * <td>{@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS}</td>
             * <td>Normal forward keyboard traversal</td>
             * <td>{@code TAB} on {@code KEY_PRESSED},
             * {@code CTRL-TAB} on {@code KEY_PRESSED}</td>
             * </tr>
             * <tr>
             * <td>{@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS}</td>
             * <td>Normal reverse keyboard traversal</td>
             * <td>{@code SHIFT-TAB} on {@code KEY_PRESSED},
             * {@code CTRL-SHIFT-TAB} on {@code KEY_PRESSED}</td>
             * </tr>
             * <tr>
             * <td>{@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}</td>
             * <td>Go up one focus traversal cycle</td>
             * <td>none</td>
             * </tr>
             * <tr>
             * <td>{@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}</td>
             * <td>Go down one focus traversal cycle</td>
             * <td>none</td>
             * </tr>
             * </table>
             * To disable a traversal key, use an empty {@code Set};
             * {@code Collections.EMPTY_SET} is recommended.
             * <p>
             * Using the {@code AWTKeyStroke} API, client code can
             * specify on which of two
             * specific {@code KeyEvent}s, {@code KEY_PRESSED} or
             * {@code KEY_RELEASED}, the focus traversal operation will
             * occur. Regardless of which {@code KeyEvent} is specified,
             * however, all {@code KeyEvent}s related to the focus
             * traversal key, including the associated {@code KEY_TYPED}
             * event, will be consumed, and will not be dispatched
             * to any {@code Component}. It is a runtime error to
             * specify a {@code KEY_TYPED} event as
             * mapping to a focus traversal operation, or to map the same event to
             * multiple default focus traversal operations.
             * <p>
             * This method may throw a {@code ClassCastException} if any {@code Object}
             * in {@code keystrokes} is not an {@code AWTKeyStroke}.
             */
            // @ts-ignore
            public setDefaultFocusTraversalKeys(id: number, keystrokes: java.util.Set): void;
            /**
             * Returns a Set of default focus traversal keys for a given traversal
             * operation. This traversal key Set will be in effect on all Windows that
             * have no such Set of their own explicitly defined. This Set will also be
             * inherited, recursively, by any child Component of those Windows that has
             * no such Set of its own explicitly defined. (See
             * <code>setDefaultFocusTraversalKeys</code> for a full description of each
             * operation.)
             */
            // @ts-ignore
            public getDefaultFocusTraversalKeys(id: number): java.util.Set;
            /**
             * Returns the current focus cycle root, if the current focus cycle root is
             * in the same context as the calling thread. If the focus owner is itself
             * a focus cycle root, then it may be ambiguous as to which Components
             * represent the next and previous Components to focus during normal focus
             * traversal. In that case, the current focus cycle root is used to
             * differentiate among the possibilities.
             * <p>
             * This method is intended to be used only by KeyboardFocusManagers and
             * focus implementations. It is not for general client use.
             */
            // @ts-ignore
            public getCurrentFocusCycleRoot(): java.awt.Container;
            /**
             * Returns the current focus cycle root, even if the calling thread is in a
             * different context than the current focus cycle root. If the focus owner
             * is itself a focus cycle root, then it may be ambiguous as to which
             * Components represent the next and previous Components to focus during
             * normal focus traversal. In that case, the current focus cycle root is
             * used to differentiate among the possibilities.
             */
            // @ts-ignore
            protected getGlobalCurrentFocusCycleRoot(): java.awt.Container;
            /**
             * Sets the current focus cycle root. If the focus owner is itself a focus
             * cycle root, then it may be ambiguous as to which Components represent
             * the next and previous Components to focus during normal focus traversal.
             * In that case, the current focus cycle root is used to differentiate
             * among the possibilities.
             * <p>
             * If a SecurityManager is installed, the calling thread must be granted
             * the "replaceKeyboardFocusManager" AWTPermission. If this permission is
             * not granted, this method will throw a SecurityException, and the current
             * focus cycle root will not be changed.
             * <p>
             * This method is intended to be used only by KeyboardFocusManagers and
             * focus implementations. It is not for general client use.
             */
            // @ts-ignore
            public setGlobalCurrentFocusCycleRoot(newFocusCycleRoot: java.awt.Container): void;
            /**
             * Adds a PropertyChangeListener to the listener list. The listener is
             * registered for all bound properties of this class, including the
             * following:
             * <ul>
             * <li>whether the KeyboardFocusManager is currently managing focus
             * for this application or applet's browser context
             * ("managingFocus")</li>
             * <li>the focus owner ("focusOwner")</li>
             * <li>the permanent focus owner ("permanentFocusOwner")</li>
             * <li>the focused Window ("focusedWindow")</li>
             * <li>the active Window ("activeWindow")</li>
             * <li>the default focus traversal policy
             * ("defaultFocusTraversalPolicy")</li>
             * <li>the Set of default FORWARD_TRAVERSAL_KEYS
             * ("forwardDefaultFocusTraversalKeys")</li>
             * <li>the Set of default BACKWARD_TRAVERSAL_KEYS
             * ("backwardDefaultFocusTraversalKeys")</li>
             * <li>the Set of default UP_CYCLE_TRAVERSAL_KEYS
             * ("upCycleDefaultFocusTraversalKeys")</li>
             * <li>the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
             * ("downCycleDefaultFocusTraversalKeys")</li>
             * <li>the current focus cycle root ("currentFocusCycleRoot")</li>
             * </ul>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public addPropertyChangeListener(listener: java.beans.PropertyChangeListener): void;
            /**
             * Removes a PropertyChangeListener from the listener list. This method
             * should be used to remove the PropertyChangeListeners that were
             * registered for all bound properties of this class.
             * <p>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public removePropertyChangeListener(listener: java.beans.PropertyChangeListener): void;
            /**
             * Returns an array of all the property change listeners
             * registered on this keyboard focus manager.
             */
            // @ts-ignore
            public getPropertyChangeListeners(): java.beans.PropertyChangeListener[];
            /**
             * Adds a PropertyChangeListener to the listener list for a specific
             * property. The specified property may be user-defined, or one of the
             * following:
             * <ul>
             * <li>whether the KeyboardFocusManager is currently managing focus
             * for this application or applet's browser context
             * ("managingFocus")</li>
             * <li>the focus owner ("focusOwner")</li>
             * <li>the permanent focus owner ("permanentFocusOwner")</li>
             * <li>the focused Window ("focusedWindow")</li>
             * <li>the active Window ("activeWindow")</li>
             * <li>the default focus traversal policy
             * ("defaultFocusTraversalPolicy")</li>
             * <li>the Set of default FORWARD_TRAVERSAL_KEYS
             * ("forwardDefaultFocusTraversalKeys")</li>
             * <li>the Set of default BACKWARD_TRAVERSAL_KEYS
             * ("backwardDefaultFocusTraversalKeys")</li>
             * <li>the Set of default UP_CYCLE_TRAVERSAL_KEYS
             * ("upCycleDefaultFocusTraversalKeys")</li>
             * <li>the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
             * ("downCycleDefaultFocusTraversalKeys")</li>
             * <li>the current focus cycle root ("currentFocusCycleRoot")</li>
             * </ul>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public addPropertyChangeListener(propertyName: string, listener: java.beans.PropertyChangeListener): void;
            /**
             * Removes a PropertyChangeListener from the listener list for a specific
             * property. This method should be used to remove PropertyChangeListeners
             * that were registered for a specific bound property.
             * <p>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public removePropertyChangeListener(propertyName: string, listener: java.beans.PropertyChangeListener): void;
            /**
             * Returns an array of all the <code>PropertyChangeListener</code>s
             * associated with the named property.
             */
            // @ts-ignore
            public getPropertyChangeListeners(propertyName: string): java.beans.PropertyChangeListener[];
            /**
             * Fires a PropertyChangeEvent in response to a change in a bound property.
             * The event will be delivered to all registered PropertyChangeListeners.
             * No event will be delivered if oldValue and newValue are the same.
             */
            // @ts-ignore
            protected firePropertyChange(propertyName: string, oldValue: java.lang.Object, newValue: java.lang.Object): void;
            /**
             * Adds a VetoableChangeListener to the listener list. The listener is
             * registered for all vetoable properties of this class, including the
             * following:
             * <ul>
             * <li>the focus owner ("focusOwner")</li>
             * <li>the permanent focus owner ("permanentFocusOwner")</li>
             * <li>the focused Window ("focusedWindow")</li>
             * <li>the active Window ("activeWindow")</li>
             * </ul>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public addVetoableChangeListener(listener: java.beans.VetoableChangeListener): void;
            /**
             * Removes a VetoableChangeListener from the listener list. This method
             * should be used to remove the VetoableChangeListeners that were
             * registered for all vetoable properties of this class.
             * <p>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public removeVetoableChangeListener(listener: java.beans.VetoableChangeListener): void;
            /**
             * Returns an array of all the vetoable change listeners
             * registered on this keyboard focus manager.
             */
            // @ts-ignore
            public getVetoableChangeListeners(): java.beans.VetoableChangeListener[];
            /**
             * Adds a VetoableChangeListener to the listener list for a specific
             * property. The specified property may be user-defined, or one of the
             * following:
             * <ul>
             * <li>the focus owner ("focusOwner")</li>
             * <li>the permanent focus owner ("permanentFocusOwner")</li>
             * <li>the focused Window ("focusedWindow")</li>
             * <li>the active Window ("activeWindow")</li>
             * </ul>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public addVetoableChangeListener(propertyName: string, listener: java.beans.VetoableChangeListener): void;
            /**
             * Removes a VetoableChangeListener from the listener list for a specific
             * property. This method should be used to remove VetoableChangeListeners
             * that were registered for a specific bound property.
             * <p>
             * If listener is null, no exception is thrown and no action is performed.
             */
            // @ts-ignore
            public removeVetoableChangeListener(propertyName: string, listener: java.beans.VetoableChangeListener): void;
            /**
             * Returns an array of all the <code>VetoableChangeListener</code>s
             * associated with the named property.
             */
            // @ts-ignore
            public getVetoableChangeListeners(propertyName: string): java.beans.VetoableChangeListener[];
            /**
             * Fires a PropertyChangeEvent in response to a change in a vetoable
             * property. The event will be delivered to all registered
             * VetoableChangeListeners. If a VetoableChangeListener throws a
             * PropertyVetoException, a new event is fired reverting all
             * VetoableChangeListeners to the old value and the exception is then
             * rethrown. No event will be delivered if oldValue and newValue are the
             * same.
             */
            // @ts-ignore
            protected fireVetoableChange(propertyName: string, oldValue: java.lang.Object, newValue: java.lang.Object): void;
            /**
             * Adds a KeyEventDispatcher to this KeyboardFocusManager's dispatcher
             * chain. This KeyboardFocusManager will request that each
             * KeyEventDispatcher dispatch KeyEvents generated by the user before
             * finally dispatching the KeyEvent itself. KeyEventDispatchers will be
             * notified in the order in which they were added. Notifications will halt
             * as soon as one KeyEventDispatcher returns <code>true</code> from its
             * <code>dispatchKeyEvent</code> method. There is no limit to the total
             * number of KeyEventDispatchers which can be added, nor to the number of
             * times which a particular KeyEventDispatcher instance can be added.
             * <p>
             * If a null dispatcher is specified, no action is taken and no exception
             * is thrown.
             * <p>
             * In a multithreaded application, {@link KeyEventDispatcher} behaves
             * the same as other AWT listeners.  See
             * <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
             * >AWT Threading Issues</a> for more details.
             */
            // @ts-ignore
            public addKeyEventDispatcher(dispatcher: java.awt.KeyEventDispatcher): void;
            /**
             * Removes a KeyEventDispatcher which was previously added to this
             * KeyboardFocusManager's dispatcher chain. This KeyboardFocusManager
             * cannot itself be removed, unless it was explicitly re-registered via a
             * call to <code>addKeyEventDispatcher</code>.
             * <p>
             * If a null dispatcher is specified, if the specified dispatcher is not
             * in the dispatcher chain, or if this KeyboardFocusManager is specified
             * without having been explicitly re-registered, no action is taken and no
             * exception is thrown.
             * <p>
             * In a multithreaded application, {@link KeyEventDispatcher} behaves
             * the same as other AWT listeners.  See
             * <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
             * >AWT Threading Issues</a> for more details.
             */
            // @ts-ignore
            public removeKeyEventDispatcher(dispatcher: java.awt.KeyEventDispatcher): void;
            /**
             * Returns this KeyboardFocusManager's KeyEventDispatcher chain as a List.
             * The List will not include this KeyboardFocusManager unless it was
             * explicitly re-registered via a call to
             * <code>addKeyEventDispatcher</code>. If no other KeyEventDispatchers are
             * registered, implementations are free to return null or a List of length
             * 0. Client code should not assume one behavior over another, nor should
             * it assume that the behavior, once established, will not change.
             */
            // @ts-ignore
            protected getKeyEventDispatchers(): java.util.List;
            /**
             * Adds a KeyEventPostProcessor to this KeyboardFocusManager's post-
             * processor chain. After a KeyEvent has been dispatched to and handled by
             * its target, KeyboardFocusManager will request that each
             * KeyEventPostProcessor perform any necessary post-processing as part
             * of the KeyEvent's final resolution. KeyEventPostProcessors
             * will be notified in the order in which they were added; the current
             * KeyboardFocusManager will be notified last. Notifications will halt
             * as soon as one KeyEventPostProcessor returns <code>true</code> from its
             * <code>postProcessKeyEvent</code> method. There is no limit to the the
             * total number of KeyEventPostProcessors that can be added, nor to the
             * number of times that a particular KeyEventPostProcessor instance can be
             * added.
             * <p>
             * If a null post-processor is specified, no action is taken and no
             * exception is thrown.
             * <p>
             * In a multithreaded application, {@link KeyEventPostProcessor} behaves
             * the same as other AWT listeners.  See
             * <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
             * >AWT Threading Issues</a> for more details.
             */
            // @ts-ignore
            public addKeyEventPostProcessor(processor: java.awt.KeyEventPostProcessor): void;
            /**
             * Removes a previously added KeyEventPostProcessor from this
             * KeyboardFocusManager's post-processor chain. This KeyboardFocusManager
             * cannot itself be entirely removed from the chain. Only additional
             * references added via <code>addKeyEventPostProcessor</code> can be
             * removed.
             * <p>
             * If a null post-processor is specified, if the specified post-processor
             * is not in the post-processor chain, or if this KeyboardFocusManager is
             * specified without having been explicitly added, no action is taken and
             * no exception is thrown.
             * <p>
             * In a multithreaded application, {@link KeyEventPostProcessor} behaves
             * the same as other AWT listeners.  See
             * <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
             * >AWT Threading Issues</a> for more details.
             */
            // @ts-ignore
            public removeKeyEventPostProcessor(processor: java.awt.KeyEventPostProcessor): void;
            /**
             * Returns this KeyboardFocusManager's KeyEventPostProcessor chain as a
             * List. The List will not include this KeyboardFocusManager unless it was
             * explicitly added via a call to <code>addKeyEventPostProcessor</code>. If
             * no KeyEventPostProcessors are registered, implementations are free to
             * return null or a List of length 0. Client code should not assume one
             * behavior over another, nor should it assume that the behavior, once
             * established, will not change.
             */
            // @ts-ignore
            protected getKeyEventPostProcessors(): java.util.List;
            /**
             * This method is called by the AWT event dispatcher requesting that the
             * current KeyboardFocusManager dispatch the specified event on its behalf.
             * It is expected that all KeyboardFocusManagers will dispatch all
             * FocusEvents, all WindowEvents related to focus, and all KeyEvents.
             * These events should be dispatched based on the KeyboardFocusManager's
             * notion of the focus owner and the focused and active Windows, sometimes
             * overriding the source of the specified AWTEvent. Dispatching must be
             * done using <code>redispatchEvent</code> to prevent the AWT event
             * dispatcher from recursively requesting that the KeyboardFocusManager
             * dispatch the event again. If this method returns <code>false</code>,
             * then the AWT event dispatcher will attempt to dispatch the event itself.
             */
            // @ts-ignore
            public abstract dispatchEvent(e: java.awt.AWTEvent): boolean;
            /**
             * Redispatches an AWTEvent in such a way that the AWT event dispatcher
             * will not recursively request that the KeyboardFocusManager, or any
             * installed KeyEventDispatchers, dispatch the event again. Client
             * implementations of <code>dispatchEvent</code> and client-defined
             * KeyEventDispatchers must call <code>redispatchEvent(target, e)</code>
             * instead of <code>target.dispatchEvent(e)</code> to dispatch an event.
             * <p>
             * This method is intended to be used only by KeyboardFocusManagers and
             * KeyEventDispatchers. It is not for general client use.
             */
            // @ts-ignore
            public redispatchEvent(target: java.awt.Component, e: java.awt.AWTEvent): void;
            /**
             * Typically this method will be called by <code>dispatchEvent</code> if no
             * other KeyEventDispatcher in the dispatcher chain dispatched the
             * KeyEvent, or if no other KeyEventDispatchers are registered. If an
             * implementation of this method returns <code>false</code>,
             * <code>dispatchEvent</code> may try to dispatch the KeyEvent itself, or
             * may simply return <code>false</code>. If <code>true</code> is returned,
             * <code>dispatchEvent</code> should return <code>true</code> as well.
             */
            // @ts-ignore
            public abstract dispatchKeyEvent(e: java.awt.event.KeyEvent): boolean;
            /**
             * This method will be called by <code>dispatchKeyEvent</code>.
             * By default, this method will handle any unconsumed KeyEvents that
             * map to an AWT <code>MenuShortcut</code> by consuming the event
             * and activating the shortcut.
             */
            // @ts-ignore
            public abstract postProcessKeyEvent(e: java.awt.event.KeyEvent): boolean;
            /**
             * This method initiates a focus traversal operation if and only if the
             * KeyEvent represents a focus traversal key for the specified
             * focusedComponent. It is expected that focusedComponent is the current
             * focus owner, although this need not be the case. If it is not,
             * focus traversal will nevertheless proceed as if focusedComponent
             * were the current focus owner.
             */
            // @ts-ignore
            public abstract processKeyEvent(focusedComponent: java.awt.Component, e: java.awt.event.KeyEvent): void;
            /**
             * Called by the AWT to notify the KeyboardFocusManager that it should
             * delay dispatching of KeyEvents until the specified Component becomes
             * the focus owner. If client code requests a focus change, and the AWT
             * determines that this request might be granted by the native windowing
             * system, then the AWT will call this method. It is the responsibility of
             * the KeyboardFocusManager to delay dispatching of KeyEvents with
             * timestamps later than the specified time stamp until the specified
             * Component receives a FOCUS_GAINED event, or the AWT cancels the delay
             * request by invoking <code>dequeueKeyEvents</code> or
             * <code>discardKeyEvents</code>.
             */
            // @ts-ignore
            protected abstract enqueueKeyEvents(after: number, untilFocused: java.awt.Component): void;
            /**
             * Called by the AWT to notify the KeyboardFocusManager that it should
             * cancel delayed dispatching of KeyEvents. All KeyEvents which were
             * enqueued because of a call to <code>enqueueKeyEvents</code> with the
             * same timestamp and Component should be released for normal dispatching
             * to the current focus owner. If the given timestamp is less than zero,
             * the outstanding enqueue request for the given Component with the <b>
             * oldest</b> timestamp (if any) should be cancelled.
             */
            // @ts-ignore
            protected abstract dequeueKeyEvents(after: number, untilFocused: java.awt.Component): void;
            /**
             * Called by the AWT to notify the KeyboardFocusManager that it should
             * cancel delayed dispatching of KeyEvents. All KeyEvents which were
             * enqueued because of one or more calls to <code>enqueueKeyEvents</code>
             * with the same Component should be discarded.
             */
            // @ts-ignore
            protected abstract discardKeyEvents(comp: java.awt.Component): void;
            /**
             * Focuses the Component after aComponent, typically based on a
             * FocusTraversalPolicy.
             */
            // @ts-ignore
            public abstract focusNextComponent(aComponent: java.awt.Component): void;
            /**
             * Focuses the Component before aComponent, typically based on a
             * FocusTraversalPolicy.
             */
            // @ts-ignore
            public abstract focusPreviousComponent(aComponent: java.awt.Component): void;
            /**
             * Moves the focus up one focus traversal cycle. Typically, the focus owner
             * is set to aComponent's focus cycle root, and the current focus cycle
             * root is set to the new focus owner's focus cycle root. If, however,
             * aComponent's focus cycle root is a Window, then typically the focus
             * owner is set to the Window's default Component to focus, and the current
             * focus cycle root is unchanged.
             */
            // @ts-ignore
            public abstract upFocusCycle(aComponent: java.awt.Component): void;
            /**
             * Moves the focus down one focus traversal cycle. Typically, if
             * aContainer is a focus cycle root, then the focus owner is set to
             * aContainer's default Component to focus, and the current focus cycle
             * root is set to aContainer. If aContainer is not a focus cycle root, then
             * no focus traversal operation occurs.
             */
            // @ts-ignore
            public abstract downFocusCycle(aContainer: java.awt.Container): void;
            /**
             * Focuses the Component after the current focus owner.
             */
            // @ts-ignore
            public focusNextComponent(): void;
            /**
             * Focuses the Component before the current focus owner.
             */
            // @ts-ignore
            public focusPreviousComponent(): void;
            /**
             * Moves the focus up one focus traversal cycle from the current focus
             * owner. Typically, the new focus owner is set to the current focus
             * owner's focus cycle root, and the current focus cycle root is set to the
             * new focus owner's focus cycle root. If, however, the current focus
             * owner's focus cycle root is a Window, then typically the focus owner is
             * set to the focus cycle root's default Component to focus, and the
             * current focus cycle root is unchanged.
             */
            // @ts-ignore
            public upFocusCycle(): void;
            /**
             * Moves the focus down one focus traversal cycle from the current focus
             * owner, if and only if the current focus owner is a Container that is a
             * focus cycle root. Typically, the focus owner is set to the current focus
             * owner's default Component to focus, and the current focus cycle root is
             * set to the current focus owner. If the current focus owner is not a
             * Container that is a focus cycle root, then no focus traversal operation
             * occurs.
             */
            // @ts-ignore
            public downFocusCycle(): void;
        }
    }
}
