declare namespace java {
    namespace security {
        // @ts-ignore
         class AccessController extends java.lang.Object {
            /**
             * Checks whether the running program is allowed to
             * access the resource being guarded by the given
             * Permission argument.
             */
            // @ts-ignore
            public static checkPermission(perm: java.security.Permission): void;
            /**
             * Answers the access controller context of the current thread,
             * including the inherited ones. It basically retrieves all the
             * protection domains from the calling stack and creates an
             * <code>AccessControlContext</code> with them.
             */
            // @ts-ignore
            public static getContext(): java.security.AccessControlContext;
            /**
             * Performs the privileged action specified by <code>action</code>.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted. In other words, the check stops here.
             * Any unchecked exception generated by this method will propagate up the chain.
             */
            // @ts-ignore
            public static doPrivileged(action: java.security.PrivilegedAction): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted iff it is granted by the AccessControlContext
             * <code>context</code>. In other words, no more checking of the current stack
             * is performed. Instead, the passed in context is checked.
             * Any unchecked exception generated by this method will propagate up the chain.
             */
            // @ts-ignore
            public static doPrivileged(action: java.security.PrivilegedAction, context: java.security.AccessControlContext): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted. In other words, the check stops here.
             * Any unchecked exception generated by this method will propagate up the chain.
             * However, checked exceptions will be caught an re-thrown as PrivilegedActionExceptions
             */
            // @ts-ignore
            public static doPrivileged(action: java.security.PrivilegedExceptionAction): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted iff it is granted by the AccessControlContext
             * <code>context</code>. In other words, no more checking of the current stack
             * is performed. Instead, the passed in context is checked.
             * Any unchecked exception generated by this method will propagate up the chain.
             * However, checked exceptions will be caught an re-thrown as PrivilegedActionExceptions
             */
            // @ts-ignore
            public static doPrivileged(action: java.security.PrivilegedExceptionAction, context: java.security.AccessControlContext): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>, retaining
             * any current DomainCombiner.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted. In other words, the check stops here.
             * Any unchecked exception generated by this method will propagate up the chain.
             */
            // @ts-ignore
            public static doPrivilegedWithCombiner(action: java.security.PrivilegedAction): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>, retaining
             * any current DomainCombiner.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted. In other words, the check stops here.
             * Any unchecked exception generated by this method will propagate up the chain.
             * However, checked exceptions will be caught an re-thrown as PrivilegedActionExceptions
             */
            // @ts-ignore
            public static doPrivilegedWithCombiner(action: java.security.PrivilegedExceptionAction): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted iff it is granted by the AccessControlContext
             * <code>context</code> and also granted by one of the permissions arguments.
             * Any unchecked exception generated by this method will propagate up the chain.
             */
            // @ts-ignore
            public static doPrivileged(action: java.security.PrivilegedAction, context: java.security.AccessControlContext, perms: java.security.Permission): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>, retaining
             * any current DomainCombiner.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted iff it is granted by one of the permissions arguments.
             * Any unchecked exception generated by this method will propagate up the chain.
             */
            // @ts-ignore
            public static doPrivilegedWithCombiner(action: java.security.PrivilegedAction, context: java.security.AccessControlContext, perms: java.security.Permission): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted iff it is granted by the AccessControlContext
             * <code>context</code> and also granted by one of the permissions arguments.
             * Any unchecked exception generated by this method will propagate up the chain.
             * However, checked exceptions will be caught an re-thrown as PrivilegedActionExceptions
             */
            // @ts-ignore
            public static doPrivileged(action: java.security.PrivilegedExceptionAction, context: java.security.AccessControlContext, perms: java.security.Permission): java.lang.Object;
            /**
             * Performs the privileged action specified by <code>action</code>, retaining
             * any current DomainCombiner.
             * <p>
             * When permission checks are made, if the permission has been granted by all
             * frames below and including the one representing the call to this method,
             * then the permission is granted and also granted by one of the permissions arguments.
             * Any unchecked exception generated by this method will propagate up the chain.
             * However, checked exceptions will be caught an re-thrown as PrivilegedActionExceptions
             */
            // @ts-ignore
            public static doPrivilegedWithCombiner(action: java.security.PrivilegedExceptionAction, context: java.security.AccessControlContext, perms: java.security.Permission): java.lang.Object;
        }
    }
}
